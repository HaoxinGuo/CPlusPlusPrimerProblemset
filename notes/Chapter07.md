# 第七章 类
类的基本思想是**数据抽象**(data abstraction)和**封装**(encapsulation)。  
数据抽象就是**接口(interface)与实现(implementation)分离**的技术。  
接口就是暴露给用户的操作，比如公有的成员函数。  
实现就是数据成员、接口的实现、私有的成员函数。  
通过**抽象数据类型(abstract data type)**，来实现数据抽象和封装。  
## 定义抽象数据类型  
封装就是隐藏，抽象数据类型隐藏了自己的成员变量，外部只能使用其接口来间接访问其成员。  
**定义成员函数**  
类内的所有成员必须声明在类的内部。  
类的成员函数可以定义在类的内部，也可以定义在类的外部。  
	定义在类内部的函数是隐式的inline函数。  
**引入this**  
当调用一个成员函数时，实际上是替某个对象调用它。  
成员函数通过名为**this**的隐式参数来访问此对象。this指向了此对象的地址。  
在成员函数内部，可以省略this来访问成员。  
this是一个常量指针，不能够修改其值。  
当成员函数中调用另一个成员函数时，将隐式传递this指针。  
```
std::string isbn() const {return this->bookNo;}
```
**引入const成员函数**  
参数列表之后，添加const关键字，表明传入的this指针是一个指向常量对象的指针。故此成员函数内，不能修改成员变量的内容。  
const对象只能调用const版本的成员函数（因此如果函数不修改成员变量，那么为了提高灵活性，应该把函数声明成const版本的）。  
C++语言的做法是允许把const关键字放在成员函数的参数列表之后，此时，紧跟在参数列表后面的const表示this是一个指向常量的指针。像这样使用const的成员函数被称作常量成员函数（const member function）。  
	常量对象，以及常量对象的引用或指针都只能调用常量成员函数。  
**类作用域和成员函数**  
类本身就是一个作用域。  
成员函数的定义必须包含其所属的类名（使用作用域运算符）。  
如果成员函数声明为const版本的，其定义时，也要在参数列表后加const。  
成员函数体可以随意使用类中的成员，无须在意成员出现的顺序，这是因为编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体。  
**定义一个返回this对象的函数**  
可以使用如下语句返回this对象：  
```c++
return *this;
```  
返回类型使用引用类型，表明返回的就是this所指的对象。  
一般来说，当我们定义的函数类似于某个内置运算符时，应该令函数的行为尽量模仿这个运算符。比如说内置的赋值运算符把它的左侧运算对象当成左值返回，这种情况下，函数就可以返回this对象的引用。  
### 定义类相关的非成员函数  
有些函数也提供了操作类对象的方法，但他们不属于类的成员函数。  
可以把这些函数放到类的头文件中声明。这些函数也可以看成是类的接口。  
有可能会把这些函数声明称友元，从而方便它们直接操作成员变量。  
### 构造函数  
类通过一个或几个特殊的成员函数初始化其成员变量，这些函数叫**构造函数（constructor）**。  
每当类对象被创建，构造函数就会被执行。  
构造函数名和类名一致，无返回类型，可能有多个（参数个数差异），不能是const的。  
对于const对象，构造函数执行完毕后，它才获得const属性。  
**合成的默认构造函数**  
如果对象没有初始值，它将执行默认初始化。  
类通过**默认构造函数(default constructor)**来执行默认初始化。如果没有显示定义过构造函数，编译器就会自动生成一个，叫做合成的默认构造函数。  
合成的默认构造函数根据如下规则初始化类成员：  
- 如果存在类内初始值，使用它来初始化成员  
- 否则，对成员执行默认初始化  
**某些类不能依赖合成的默认构造函数**  
所谓不能依赖，就是不可以让编译器生成默认构造函数，要自己定义一个。其原因可能是：  
- 如果定义了自己的构造函数，那么编译器就不会生成默认的构造函数，此类就没有了默认构造函数。  
- 默认构造函数可能执行的是错误的操作，比如内置类型若没有类内初始值，则进行默认初始化，其值未定义。  
- 有时候，编译器无法生成默认构造函数，比如类成员中有类，而此类有可能没有默认构造函数。  
**=default的含义**  
C++11中，使用这种语句来让编译器生成一个默认构造函数：  
```c++
SalesData() = default;
```  
	这种情况下，应当对内置类型的数据成员提供类内初始值，否则应当使用构造函数初始值列表形式的默认构造函数。  
**构造函数初始值列表**  
```c++
Sales_data(const std::string &s):
									bookNo(s){}
Sales_data(const std::string &s,unsigned n,double p):
														bookNo(s),units_sold(n),revenue(p*n){}
```
参数列表后，函数体前的一部分内容叫构造函数初始值列表（constructor initialize list）。  
它负责为对象的成员变量赋初值。  
如果成员不在初始化列表中，它用类内初始值初始化（如果存在），否则执行默认初始化。  
	构造函数不应该轻易覆盖掉类内的初始值，除非新赋的值与原值不同。如果你不能使用类内初始值，则所有构造函数都应该显式地初始化每个内置类型的成员。
**在类的外部定义构造函数**
```c++
Sales data:：Sales data（std:：istream&is）
{
read（is，*this）；//read函数的作用是从is中读取一条交易信息然后
					//存入this对象中
}
```
为了更好地理解调用函数 read的意义，要特别注意read的第二个参数是一个Sales data对象的引用。在7.1.2节（第232页）中曾经提到过，使用this来把对象当成一个整体访问，而非直接访问对象的某个成员。因此在此例中，我们使用*this将
“this”对象作为实参传递给read函数。  
### 拷贝、赋值和析构  
拷贝构造函数，当初始化变量时以值传递或函数返回一个对象时，会发生拷贝。  
赋值运算，当使用了赋值运算符时，会发生对象的赋值操作。  
析构函数，当一个变量不在存在时，会执行析构。  
这些操作如果不显示定义，编译器就会合成一个，合成的拷贝赋值版本只是做了浅拷贝操作。  
**某些类不能依赖合成的版本**  
如果类中有成员绑定了外部的对象（比如动态内存），那么就不可依赖合成的版本。  
可使用容器管理必要的存储空间，当发生拷贝等操作时，容器也会执行正确的拷贝。  
## 访问控制与封装  
使用**访问说明符（access specifiers）**加强类的封装性。  
- public说明符之后的成员对外可见，外部可访问，public成员定义类的接口。  
- private说明符之后的成员对内可见，外部无法访问，即隐藏了实现细节。  
**class和struct**  
其区别仅仅在于默认的访问权限。class默认为private，struct默认是public。  
	作为接口，应当是public的，而实现细节（数据成员或相关函数）应当为private的。  
### 友元  
类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的友元（friend）。即在函数或类前面加friend关键字。  
友元声明只能出现在类的内部。它并非函数声明，函数声明还要在别的地方声明。  
一般来说，最好在类定义的开始或结束前的位置集中声明友元。  
"封装的益处"
	封装有两个重要的优点：  
	- 确保用户代码不会无意间破坏封装对象的状态。  
	- 被封装的类的具体实现可以随时改变，而无须调整用户级别的代码。  
## 类的其它特性  
### 类成员再探
**定义一个类型成员**  
可以在类的内部定义一个类型（使用typedef或using），这个类型也有访问限制。  
通常放在类的开头位置。  
**令成员作为内联函数**  
规模较小的成员函数适合声明成内联函数（定义时在前面加inline即可）。  
如果定义在类内的函数，默认就是inline的。  
inline成员函数通常定义到类的头文件中，即声明和定义在同一个文件中。  
**重载成员函数**  
和普通函数的重载规则一样。只要参数的数量or类型有区别，就可以重载。  
如果是const版本的成员函数（传入const this），那么也可以重载。因为本质上，其隐式参数this的类型改变了。  
**类数据成员的初始值**  
可以给类数据成员一个类内初始值。使用等号或者花括号。  
### 返回\*this的成员函数
返回引用的函数是左值的，意味着这些函数（返回\*this）返回的是对象本身而非对象的副本。  
	一个const成员函数如果以引用的形式返回\*this，那么它的返回类型将是常量引用。  
但是如此一来（const成员函数返回const引用），就无法继续让返回的对象调用非常量版本的成员函数。一个解决的办法就是**重载一个非常量版本的接口**，定义一个私有的常量版本的函数，负责具体工作，而非常量版本的接口负责调用它，并返回非常量引用。  
建议：对于公共代码使用私有功能函数。  
### 类类型  
每个类是一个唯一的类型，即使其内容完全一样。  
**类的声明**  
可以暂时声明类而不定义它，这叫前置声明（forward declaration）。  
这种类型，在没有定义前是一个不完全类型（incomplete type）。这种类型只能在有限的情况下使用：  
- 定义指向这种类型的指针or引用  
- 声明以不完全类型为参数or返回值的函数  
要创建一个类的对象，则必须已经定义好了这个类，这是因为编译器需要知道类的存储空间大小。  
只有被定义，才能访问其成员。  
声明一个前置类型的方法：  
```c++
class A;
struct B;
namespace game
{
    class C;    // 前置声明一个在命名空间中的类
}
```  
### 友元再探  
类可以把普通函数定义成友元，也可以把类，类的成员函数定义成友元。  
友元类有权访问本类的非公有成员。  




















