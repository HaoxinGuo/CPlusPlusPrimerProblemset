# 面向对象程序设计

面向对象程序设计基于三个基本概念：数据抽象、继承、动态绑定。

---------

## OOP概述

**面向对象程序设计(object-oriented programming)**的核心思想时数据抽象，继承和动态绑定。通过数据抽象我们可以将类的接口和实现分开，使用继承，我们可以定义相似的类型并对其相似关系建模；使用动态绑定，我们可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。

**继承**

通过继承(inheritance)；联系在一起的类构成一种层次关系。通常在层次关系的根部有一个基类(base class)，其他类则间接或直接地从基类继承而来，这些继承而来的类称为派生类(derived class)。基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。

```c++
class Quote{
public:
	std::string isbn() const;
	virtual double net_price(std::size_t n) const;
};

class Bulk_Quote:public Quote{
public:
	double net_price(std::size_t n) const override;
};
```

**动态绑定**

通过使用动态绑定(dynamic binding)，我们能用用一段代码分别处理Quote和Bulk_Quote的对象。

```c++
//计算并打印销售给定数量的某种书籍所得的费用
double print_total(ostream &os,const Quote &item,size_t n){
	//根据传入item的形参的对象调用Quote::net_price()
	//或者Bulk_Quote::net_price
	double ret = item.net_price(n);
	os<<"ISBN: "<<item.isbn()<< "# sold: "<<n<< "total due "<<ret<<endl;
	return ret;
}

//basic的类型时Quote,bulk的类型是Bulk_Quote

print_total(cout,basic,20);//调用Quote::net_price()

print_total(cout,bulk,20);//调用Bulk_Quote::net_price()
```

	当我们使用基类的引用或者指针调用一个虚函数时将发生动态绑定。

## 定义基类和派生类

### 定义基类

```c++
class Quote{
public:
	Quote() = default;
	Quote(std::string &book,double sales_price):bookNo(book),price(sales_price){}
	std::string isbn() const {return bookNo;};
	virtual double net_price(size_t n) const {return n*price;}
	virtual ~Quote()
private:
	std::string bookNo;
protected:
	double pricr = 0.0;
};
```

	通常，基类都应该定义一个虚析构函数，即使该函数在不执行任何实际操作也是如此。

**成员函数和继承**

成员函数如果没有被定义为虚函数，则其解析过程在发生编译时而不是运行时。

基类通过在其成员函数的声明语句之前加上关键词virtual使得该函数执行动态绑定。

**访问控制和继承**

派生类可以继承定义在基类的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员。派生类可以访问公有成员，而不能访问私有成员。不过，如果基类希望它的派生类有权访问该成员，同时禁止其他用户访问。我们用受保护的(protected)访问运算符说明这样的成员。

### 定义派生类

派生类必须使用类派生列表(class derivation list)明确指出它是从哪个基类继承而来的。

**派生类中的虚函数**

C++新标准允许派生类显式的注明它使用某个成员函数覆盖了它继承的虚函数。具体做法是在形参列表后面、或者在const成员函数的const关键词后面，或者在引用函数的引用限定符后面添加一个关键词override。

**派生类对象及派生类向基类的类型转换**

因为在派生类对象中含有基类对应的组成部分，所以我们能够把派生类的对象当成基类对象来使用，而且我们也能将基类的指针或引用绑定到派生类对象的基类部分上。

```c++
Quote item;		//基类对象
Bulk_Quote bulk;		//派生类对象
Quote *p = &item;		//p指向Quote对象
p = &bulk;		//p指向bulk的Quote部分
Quote &r = bulk;		r绑定到bulk的Quote部分
```

**派生类构造函数**

```c++
Bulk_Quote(const string &book,double p,size_t qty,double disc):
			Quote(book,p),min_qty(qty),discount(dis){}
```

	首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。

**派生类使用基类的成员**

派生类可以使用基类的公有和保护成员。

**继承与静态成员**

静态成员遵循通用的访问规则。

**被用作基类的类**

如果我们想将某个类作为基类，则该类必须已经定义而非仅仅声明：

```c++
class Quote;		//声明但未定义；
//错误：quote必须被定义
class Bulk_Quote:public Quote{...};
```

**防止继承的发生**

在类名后加一个final可以防止继承的发生。

```c++
class NoDerived final{};
```

### 类型转换与继承

可以将基类的指针或者引用绑定到派生类的对象上有一层极为重要的含义：当使用基类的引用或指针时，实际上我们不知道该引用（指针）所绑定对象的真实类型。该对象可能是基类的对象，也可能是派生类的对象。

**动态类型与静态类型**

我们必须把一个变量或者表达式的静态类型与该表达式表示对象的动态类型区分开来。表达式的静态类型在编译时总是已知的，它是变量声明时的类型或者表达式生成的类型；动态类型则是变量或者表达式表示的内存中的对象的类型。动态类型直到运行时才可知。

例如：当print_total调用net_price时`double ret = item.net_price(n);`

我们知道item的静态类型是Quote&，它的动态类型则依赖于item绑定的实参，动态类型直到运行时才可知。

**不存在从基类向派生类的隐式类型转换......**

因为一个基类的对象可能是派生类对象的一部分，也可能不是，所以不存在从基类到派生类的自动类型转换。

```c++
Quote base;
Bulk_Quote* bulkp = &base;		//错误：不能将基类转换成派生类
Bulk_Quote& bulkref = base;		//错误：不能将基类转换成派生类
Bulk_Quote bulk;
Quote *itemp = &bulk;		//正确：动态类型是Bulk_Quote
Bulk_Quote *bulkp = itemp;		//错误：不能将基类转换成派生类
```

**......在对象之间不存在类型转换**

	当我们用一个派生类为一个基类对象赋值时，只有该派生类对象中的基类部分会被拷贝，移动和赋值，它的派生类部分会被忽略掉。


## 虚函数

我们必须为每个虚函数提供定义。

**对虚函数的调用可能在运行时才被解析**

动态绑定只有当我们通过指针或者引用调用虚函数时才会发生。

**派生类中的虚函数**

一旦某个函数被声明为虚函数，则在所有的派生类中它都是虚函数。

	基类中的虚函数在派生了中隐含地也是一个虚函数。
	当派生类覆盖某个虚函数时，该函数的形参必须与派生类的形参严格匹配。
	返回类型在返回的是类的指针或者引用时可不一样，但是要求从基类到派生类的类型转换是可访问的。

**final和override说明符**

final和override说明符出现在形参列表（包括任何const或引用修饰符）以及尾置返回类型之后。

**虚函数和默认实参**

	如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。

**回避虚函数机制**

在某些情况下，我们希望对虚函数的调用不要动态绑定，而是强迫其执行虚函数的某个特定版本。使用作用域运算符可以实现这一目的：

```c++
//强行调用基类中定义的函数版本而不管baseP的动态类型如何
double undiscount = baseP->Quote::net_price(42);
```

## 抽象基类

**纯虚函数**

纯虚函数无需定义、我们在函数体的位置书写=0就可以将一个虚函数说明为纯虚函数。其中，=0只能出现在类内部的虚函数声明语句处。

```c++
double net_price(size_t) const =0;
```

**含有纯虚函数的类是抽象基类**

抽象基类负责定义接口，而后续的其他类可以覆盖该接口。我们不能创建一个抽象基类的对象。因为Disc_quoto将net_price定义为纯虚函数，所以我们不能定义Disc_quote的对象。我们可以定义Disc_quote的派生类的对象。前提是这些类覆盖了net_price函数。

	我们不能创建抽象基类的对象。

**派生类构造函数只初始化它的直接基类**

## 访问控制与继承

**受保护的成员**

protected说明符可以看做是public和private中和后的产物：

1. 和私有成员类似，受保护的成员对于类的用户来说是不可访问的

2. 和公有成员类似，受保护的成员对于派生类的成员和友元来说是可访问的

3. **派生类的成员只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中受保护的成员没有任何访问特权**

```c++
class Base{
protected:
	int prot_mem;
};

class Sneaky:public Base{
	friend void clobber(Sneaky&);//能访问Sneaky::prot_mem
	friend void clobber(Base&);//不能访问Base::prot_mem
	int j;
};

//正确，clobber能够访问Sneaky对象的private和protected成员
void clobber(Snaaky &s){s.j=s.prot_mem=0;}
//错误;clobber不能访问Base的protected成员
void clobber(base &s){s.prot_mem=0;}
```

**公有，私有和受保护继承**

某个类对其继承而来的成员的访问权限受到两个因素的影响：

1. 在基类中该成员的访问说明符

2. 在派生类的派生列表中的访问说明符

派生类说明符的目的是控制派生类影虎对于基类成员的访问权限，还可以控制继承自派生类的新类的访问权限。

**派生类向基类转换的可访问性**

派生类向基类的转换是否可访问由使用该转换的代码决定，同时派生类的派生访问说明符也会有影响。假定D继承自B：

- 只有当D公有地继承B时，用户代码才能使用派生类向基类的转换；如果D继承B的方式是受保护的或者私有的，则用户代码不能使用该转换。

- 不论以什么方式继承B，D的成员和友元都能使用派生类向基类的转换；派生类向其直接基类的类型转换对于派生类的成员和友元来说都是可访问的。

- 如果D继承B的方式是公有的或者受保护的，则D的派生类的成员和友元可以使用D向B的转换；反之，如果D继承B的方式是私有的，则不能使用。

	对于代码中的某个给定节点来说，如果基类的公有成员是可访问的，则派生类向基类的类型转换也是可访问的；反之则不行。

**友元与继承**

友元关系不能继承，基类的友元在访问派生类成员时不具有特殊性，类似的，派生类的友元也不能随意访问基类的成员。

**改变个别成员的可访问性**

有时候我们需要改变派生类继承的某个名字的访问级别，通过using声明可以达到这一目的：

```c++
class Base {
public:
	std::size_t size() const { return n; }
protected:
	std::size_t n;
};

class Derived : private Base {
public:
	// 令size成员保持public访问级别
	using Base::size;
protected:
	using Base::n;
};
```

因为Derived使用了私有继承，所以继承而来的成员size和n默认情况下是Derived的私有成员。然而，我们使用using声明语句改变了这些成员的可访问性。

通过在类的内部使用using声明语句，我们可以将该类的直接或间接基类中任何可访问成员标记出来。using声明语句中名字的访问权限由该using声明语句之前的访问说明符来决定。

	派生类只能为那些它可以访问的名字提供using声明。

**默认的继承保护级别**

默认情况下，使用class关键词定义的派生类是私有继承，而使用struct关键字定义的派生类为公有继承。

## 继承中的类作用域

每个类定义自己的作用域，在这个作用域内我们定义类的成员。

当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内，所以派生类才能像使用自己的成员一样使用基类的成员。

**在编译时进行名字查找**

一个对象、引用或指针的静态类型决定了该对象的哪些成员是可见的。即使静态类型与动态类型可能不一致（当使用基类的引用或指针时会发生这种情况），但是我们能使用哪些成员仍然是由静态类型决定的。

**名字冲突和继承**

和其他作用域一样，派生类也能重用定义在其直接基类或间接基类中的名字，此时定义在内层作用域（即派生类）的名字将隐藏定义在外层作用域（即基类）的名字。

	派生类将隐藏同名的基类成员。

**通过作用域运算符来使用隐藏的成员**

作用域运算符将覆盖掉原有的查找规则。

	除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字。

**名字查找先去类型检查**

```c++
struct Base{
	Base():mem(0){};
	int memfcn();
protected:
	int mem;
};

struct Derived:Base{
	Derived(int i):mem(i){};
	int memfcn(int);
	int get_mem(){return mem;};
protected:
	int mem;
};

Derived d;
Base b;
b.memfcn();		//调用Base::memfcn
d.memfcn(10);		//调用Derived::memfcn
d.memfcn();		//错误：参数列表为空的memfcn被隐藏了
d.Base::memfcn();		//正确：调用Base::memfcn
```

**虚函数和作用域**

加入基类与派生类的虚函数接受的实参不同，则我们就无法通过基类的引用或指针调用派生类的虚函数。

**通过基类调用隐藏的虚函数**

## 构造函数与拷贝控制

和其他类一样，位于继承体系中的类也需要控制当其对象执行一系列操作时发送什么样的行为，这些操作包括创建、拷贝、移动、赋值和销毁。

### 虚析构函数

当我们delete一个动态分配的对象的指针时，将执行析构函数。如果该指针指向继承体系中的某个类型，则有可能出现指针的静态类型与被删除对象的动态类型不符的情况。我们通过在基类中奖析构函数定义成虚析构函数以确保执行正确的析构函数版本。

```c++
class Quote {
public:
	// 如果我们删除的是一个指向派生类对象的基类指针，则需要虚析构函数
	virtual ~Quote() = default;	// 动态绑定析构函数
};
```

	如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为。

之前介绍的经验准则说，如果一个类需要析构函数，那么它同样需要拷贝和赋值操作。但这里基类的析构函数并不遵顼这个准则，它是一个重要的例外。

虚析构函数还将阻止合成移动操作。

### 合成拷贝控制与继承

基类或派生类的合成拷贝控制成员的行为与其他合成的构造函数、赋值运算符或析构函数类似：它们对类本身的成员依次进行初始化、赋值或销毁操作。此外，合成的成员还负责使用直接基类中对应的操作对一个对象的直接基类部分进行初始化、赋值或销毁的操作。例如：

- 合成的Bulk_quote默认构造函数运行Disc_quote的默认构造函数，后者又运行Quote的默认构造函数。

- Quote的默认构造函数将bookNo成员默认初始化为空子行串，同时便用类内例始值将price初始化为0。

- Quote的构造函数完成后，继续执行Disc_quote的构造函数，它使用类内初始值初始化qty和discount。

- Disc quote的构造函数完成后，继续执行Bu1k_quote的构造函数，但是它什么具体工作也不做。

**对于派生类的析构函数来说，它除了销毁派生类自己的成员外，还负责销毁派生类的直接基类；该直接基类又销毁它自己的直接基类，以此类推直至继承链的顶端。**

**派生类中删除的拷贝控制与基类的关系**

某些定义为基类的方式也可能导致有的派生类成员成为删除的函数：

-. 如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的函数或者不可访问（参见15.5节，第543页），则派生类中对应的成员将是被删除的，原因是编译器不能使用基类成员来执行派生类对象基类部分的构造、赋值或销毁操作。

-. 如果在基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认和拷贝构造函数将是被删除的，因为编译器无法销毁派生类对象的基类部分。

-. 和过去一样，编译器将不会合成一个删除掉的移动操作。当我们使用=defau1t请求一个移动操作时，如果基类中的对应操作是删除的或不可访问的，那么派生类中该函数将是被删除的，原因是派生类对象的基类部分不可移动。同样，如果基类的析构函数是删除的或不可访问的，则派生类的移动构造函数也将是被删除的。

例如：

```c++
class B{
public:
	B();
	B(const B&)=delete;
};

class D:public B{
	//没有声明任何构造函数
};

D d;		//正确，D的合成默认构造函数使用B的默认构造函数
D d2(d);		//错误：D的合成拷贝构造函数是被删除的
D d3(std::move(d));		//错误：隐式的使用D的被删除的拷贝构造函数
```

**移动操作和继承**

因为基类缺少移动操作会阻止派生类拥有自己的移动操作，所以当我们确实需要执行移动操作时应该首先在基类中进行定义。

```c++
class Quote{
public:
	Quote()=default;//对成员依次进行默认初始化
	Quote(const Quote&)=default;//对成员依次拷贝
	Quote(Quote&&)=default;//对成员依次拷贝
	Quote& operator=(const Quote&)=default;//拷贝赋值
	Quote& operator=(Quote&&)=default;//拷贝赋值
	virtual ~Quote()=default;//析构函数
}
```

### 派生类的拷贝控制成员

派生类的构造函数在其初始化阶段中不但要初始化派生类自己的成员，还负责初始化派生类对象的基类部分。因此，派生类的拷贝和移动构造函数在拷贝和移动自有成员的同时，也要移动和拷贝基类部分的成员。类似的，派生类赋值运算符也必须为其基类部分的成员赋值。

和构造函数及赋值运算符不同的是，析构函数只负责销毁自己分配的资源。

	当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象。

**定义派生类的拷贝和移动构造函数**

当为派生类定义拷贝或移动构造函数时，我们通常使用对应的基类构造函数初始化对象的基类部分：

```c++
class Base{/* */};
class D:public Base{
public:
	//默认情况下，基类的默认构造函数初始化对象的基类部分
	//要想使用拷贝或移动构造函数，我们必须在构造函数初始列表中
	//显式的调用该构造函数
	D(const D&):Base(d)		//拷贝基类成员
			/*D的成员的初始值*/{ /* */}
	D(D&& d):Base(std::move(d))		//移动基类成员
			/*D的成员的初始值*/{ /* */}
};
```

	在默认情况下，其基类默认构造函数初始化派生类对象的基类部分。如果我们想拷贝或者移动基类部分，则必须在派生类的构造函数初始值列表中显式的使用基类的拷贝构造函数。

**派生类赋值运算符**

派生类的赋值运算符也必须显式地为其基类部分赋值。

```c++
//Base::operator=(const Base&)不会被自动调用
D &D::operator=(const D &rhs){
	Base::operator=(rhs);//为基类部分赋值
	//按照过去的方式为派生类的成员赋值
	//酌情处理自赋值及释放已有资源等情况
	return *this;
}
```

**派生类析构函数**

派生类析构函数只负责销毁由派生类自己分配的资源。

**在构造函数和析构函数中调用虚函数**

### 继承的构造函数

**类不能继承默认、拷贝、移动构造函数**，如果派生类没有直接定义这些构造函数，则编译器将为派生类合成它们。

在C++11新标准中，派生类能够重用其直接基类定义的构造函数。

一个类只初始化它的直接基类，出于同样的原因，一个类也只继承其直接基类的构造函数。类不能继承默认、拷贝和移动构造函数。如果派生类没有直接定义这些构造函数，则编译器将为派生类合成它们。

派生类继承基类构造函数的方式是提供一条注明了（直接）基类名的using声明语句。

```c++
class Bulk_quote : public Disc_quote {
public:
	using Disc_quote::Disc_quote; // 继承Disc_quote的构造函数
	double net_price(std::size_t) const;
};
```

通常情况下，using声明语句只是令某个名字在当前作用域内可见。当当作用于构造函数时，using声明语句将令编译器产生代码。对于基类的每个构造函数，编译器都在派生类中生成一个形参列表完全相同的构造函数。

在Bulk_quote类中，继承的构造函数等价于：

```c++
Bulk_quote(const std::string &book, double price, std::size_t qty, double disc) :
	Disc_quote(book, price, qty, disc) {}
```

如果派生类含有自己的数据成员，则这些成员将被默认初始化。

**继承的构造函数的特点**

一个构造函数的using声明不会改变该构造函数的访问级别。不能指定explicit和constexpr。

## 容器与继承






















































