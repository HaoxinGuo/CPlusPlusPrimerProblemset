# 表达式
1. `*iter.empty()`和`(*iter).empty()`和`iter->empty()`的区别  
2. `somevalue ? ++x,++y:--x,--y;`等价于`(somevalue ? ++x,++y:--x),--y;`
# 位运算符

位运算符作用于整数类型的运算对象，并把运算对象看成是二进制位的集合。
|运算符|功能|用法|
|-|-|-|
|~|位求反|~expr|
|<<|左移|expr1 << expr2|
|>>|右移|expr1 >> expr2|
|&|位与|expr1 & expr2|
|^|位异或|expr1 ^ expr2|
|\||位或|expr1 \| expr2|
  
一般来说，如果运算对象是“小整型”，则它的值会被自动提升成较大的整数类型。运算对象可以是带符号的，也可以是无符号的。如果运算对象是带符号的且它的值为负，那么位运算如何处理运算对象的“符号位”依赖于机器。  
强烈建议将位运算符用于处理无符号类型。  
一个提升例子就是，如果对char做位运算，它会先被提升为int。  
**移位运算符**
<<和>>  
运算符的内置含义是对其运算对象执行基于二进制位的移动操作。首先令左侧运算对象的内容按照右侧运算对象的要求移动指定位数，然后将经过移动的（可能还进行了提升）左侧运算对象的拷贝作为求值结果。其中，右侧的运算对象一定不能为负，而且必须严格小于结果的位数，否则就会产生未定义的行为。移出边界之外的位数被舍弃掉了。  
左移运算符<<在右侧插入值为0的二进制位。右移运算符>>的行为依赖于左侧运算对象的类型：如果是无符号的，在左侧插入值为0的二进制位；如果是带符号的，在左侧插入符号位的副本或值为0的二进制位，如何选择视具体环境而定。  
# sizeof运算符  
sizeof运算符返回一条表达式或一个类型名字所占的字节数。sizeof运算符满足右结合律，其所得的值是一个size_t类型的常量表达式。它有两种形式：  
- sizeof(type)
- sizeof?expr
常量表达式意味着在编译期间就能得到计算。  
第二种形式中，sizeof返回的是表达式结果类型的大小。  
sizeof运算符的结果部分地依赖于其作用的类型：  
- 对char或者类型为char的表达式执行sizeof运算，结果得1。
- 对引用类型执行sizeof运算得到被引用对象所占空间大小。
- 对指针执行sizeof运算得到指针本身所占空间的大小。
- 对解引用指针执行sizeof运算得到指针指向对象所占空间的大小，指针不需要有效。
- 对数组执行sizeof运算得到整个数组所占空间大小。
- 对string对象或vector执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。
# ?显式转换
**命名的强制类型转换**  
一个命名的强制类型转换有如下形式：  
cast-name<type>(expression);  
其中，type是转换的目标类型而expression是要转换的值。如果type是引用类型，则结果是左值。cast-name是static_cast,?dynamic_cast,?const_cast和reinterpret_cast中的一种。dynamic_cast支持运行时识别，直到19章（p730）才会讲解。  
**static_cast**  
任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。
```
//?进行强制类型转换以便执行浮点数除法
double?slope?=?static_cast<double>(j)?/?i;
```  
当需要把一个较大的算术类型赋值给较小的类型时，static_cast非常有用。此时，强制类型转换表示，我们知道并且不在乎潜在的精度损失。  
static_cast对于编译器无法自动执行的类型转换也非常有用。例如，我们可以使用static_cast找回存在于void\*的指针中的值：  
```
void?*p?=?&d;????//?正确，任何非常量对象的地址都能存入void*

//?正确，将void*转换回初始的指针类型
double?*dp?=?static_cast<double*>(p);
```  
必须确保转换后所得的类型就是指针所指的类型。类型一旦不符，将产生未定义的后果。  
**const_cast**  
const_cast只能改变运算对象的底层const：  
```
const?char?*pc;
char?*p?=?const_cast<char*>(pc);????//?正确，但是通过p写值是未定义的行为
```  
如果对象本身是一个非常量，使用强制类型转换获得写权限是合法的行为。然而如果对象是一个常量，执行写操作就会产生未定义的后果。  
const_cast常常用于有函数重载的上下文中，这将在第6章介绍（p208）。  
**reinterpret_cast**  
reinterpret_cast通常为运算对象的位模式提供较低层次上的重新解释。比如：  
```
int?*ip;
char?*pc?=?reinterpret_cast<char*>(ip);
```  
我们必须牢记pc所指的真实对象是一个int而非字符。  
	reinterpret_cast非常危险，书中建议尽量避免使用。因为它本质上依赖于机器。且没有介绍应用场景。另外，书中也建议尽量避免其他的强制类型转换，强制类型转换应当在其合适的应用场景中使用。  
**旧式的强制类型转换**  
在早期版本的C++语言中，显式地进行强制类型转换包含两种形式：  
```
type(expr);???//?函数形式的强制类型转换
(type)expr;???//?C语言风格的强制类型转换
```  
根据所涉及的类型不同，旧式的强制类型转换分别具有const_cast,?static_cast或reinterpret_cast相似的行为。  
	与命名的强制类型转换相比，旧式的强制类型转换从表现形式上来说不那么清晰明了，容易被看漏，所以一旦转换过程出现问题，追踪起来也更加困难。