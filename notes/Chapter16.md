# 模板和泛型编程

## 定义模板

### 函数模板

一个函数模板就是一个公式，可用来生成针对特定类型的函数版本。compare的模板函数可以像这样：

```c++
template<typename T>
int compare(const T &v1,const T &v2){
	return  v1 > v2 ? 1 : -1;
}
```

模板定义以一个关键词template开始，后跟一个模板参数列表，这是一个逗号分隔或多个模板参数的列表，用< 和 > 包围起来。

	在模板定义中，模板参数列表不能为空。

**实例化参数模板**

'''c++
cout<<compare(1,0)<<endl;//T为int
'''

**模板类型参数**

类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或者类型转换。

**非类型模板参数**

一个非类型模板参数表示一个值而非一个类型。我们通过一个特定的类型名而非关键字class或者typename来指定非类型参数。

	非类型模板参数的模板实参必须是常亮表达式。

**inline和constexpr的函数模板**

inline或者constexpr说明符放在参数列表之后，返回类型之前：

```c++
template<typename T>
inline T min(const T &a,const T &b)
```

**编写类型无关的代码**

编写泛型代码的两个重要的原则：

1. 模板中的函数参数是const的引用；

2. 函数体的条件判断仅使用<比较运算。

**模板编译**

## 类模板















