# 第三章 字符串、向量和数组

## String
1. **头文件不应包含using声明**  
2. **初始化string对象的方式：**  
```c++
string?s1;???????????//?默认初始化，s1是一个空串
string?s2(s1);???????//?s2是s1的副本
string?s2?=?s1;??????//?等价于s2(s1)
string?s3("value");??//?s3是字面值"value"的副本，不包括最后的空字符
string?s3?=?"value";?//?等价于s3("value")
string?s4(n,?'c');???//?初始化为由n个字符c组成的串
```  
3. **直接初始化和拷贝初始化**  

如果使用等号（=）初始化一个变量，实际上执行的是**拷贝初始化（copy?initialization）**，编译器把等号右侧的对象初始值拷贝到新创建的对象中去。如果不适用等号，则执行的是**直接初始化**（direct?initialization）。  
```c++
string?s5?=?"hiya";??//?拷贝初始化
string?s6("hiya");???//?直接初始化
string?s7(10,?'c');??//?直接初始化
```  
4. getline函数会读取换行符，但不会把它存入字符串中。getline返回输入流。  

**string::size_type类型**  

size函数返回的是一个string::size_type类型的值。这是一个无符号的整数。  
5. **处理每个字符？使用基于范围的for语句**  

如果想对string对象中的每个字符做点儿什么操作，目前最好的办法是使用C++11新标准提供的一种语句：**范围for**（range?for）语句。这种语句遍历序列中的每个元素并对序列中的每个值执行某种操作，其语法格式是：  

```c++
for?(declaration?:?expression)
????statement
```  
如：  
```c++
for?(auto?c?:?str)
????//?do?something
```  
**使用下标运算符**

`[?]`符号叫做下标运算符，范围是`[0,?s.size())`，越界的结果是UB（undefined?behavior，未定义行为）。  

## Vector
1. vector是对象的集合，也叫容器（container）。集合中的每个对象都有一个索引，索引用于访问对象。  
2. vector是一个类模板。模板是为编译器提供的一份生成类或函数的说明。  
3. vector是模板而非类型，由vector生成的类型必须包含元素的类型，如：  
```c++
vector<int>?v;
```  
4. **vector中存放的是对象，而引用不是对象，故不能存储引用。**  
### 定义和初始化vector对象  
vector模板控制着初始化向量的方法。定义vector对象的方法有：  
- `vector<T>?v1`，默认初始化，v1是一个空的vector  
- `vector<T>?v2(v1)`，v2中包含v1所有元素的副本  
- `vector<T>?v2?=?v1`，等价于v2(v1)  
- `vector<T>?v3(n,?val)`，v3包含了n个重复的元素，每个元素的值都是val  
- `vector<T>?v4(n)`，v4包含了n个执行了值初始化的对象  
- `vector<T>?v5{a,b,c...}`，v5里包含了用a,b,c...初始化的元素  
- `vector<T>?v5?=?{a,b,c...}`，等价于`vector<T>?v5{a,b,c...}`  
**值初始化**  
值初始化（value?initialize），是指如果是内置类型，则初始值为0；如果是类类型，执行类默认初始化。
`vector<T>(n)`中，所有元素将执行值初始化。
###?向vector中添加元素
push_back函数把一个元素压入vector对象的尾端。  
vector的对象能高效地增长，因此更常见的情况是：创建一个空vector，然后在运行时再利用vector的成员函数push_back向其中添加元素。  
**一定不能在遍历vector的时候改变vector对象的大小。**  
C++标准要求vector应该能在运行时高效快速地添加元素。因此既然vector对象能高效地增长，那么在定义vector对象的时候设定其大小就没有什么必要了，只有一种例外，即当所有元素的值都一样。一旦元素的值有所不同，更有效的办法是先定义一个空的vector对象，再在运行时向其中添加具体值。  
### 其它vector操作
如（很多和string类似）：
- `v.empty()`，如果v不含有任何元素，返回true  
- `v.size()`，返回v中的元素个数  
- `v[n]`，返回v中第n个位置上元素的引用  
- `v1?=?v2`，v2中的元素将拷贝替换v1的  
- `v1?=?{a,b,c...}`，列表中的元素将拷贝替换v1中的  
- `v1?==?v2`,?`v1?!=?v2`，元素数量相同，对应位置的元素也相等，则相等  
- <,<=,>,>=，比首个相异元素的大小，如都一样，比长度，即字典顺序  
size返回的类型由vector定义的size_type类型。
```c++
vector<int>::size_type????//?正确
vector::size_type?????????//?错误
```  
**只有当元素的值可比较时，vector对象才能被比较。只能对确已存在的元素执行下标操作。**  
## 迭代器介绍
使用迭代器（iterator）是一种通用的访问容器中元素的方法。
迭代器有有效和无效之分。有效的迭代器指向某个元素，或指向尾元素的下一个位置，其它情况都属于无效。
### 使用迭代器
有迭代器的类型同时拥有返回迭代器的成员。  
标准库容器都拥有名为begin和end的成员（函数）。其中begin成员负责返回指向第一个元素的迭代器。  
end成员负责返回指向容器“尾元素的下一个位置”的迭代器。叫**尾后迭代器（off-the-end?iterator）**。  
如果容器为空，begin和end都返回尾后迭代器。即：`v.begin()?==?v.end()`  
如：  
```c++
auto?b?=?v.begin();
auto?e?=?v.end();
```  
**迭代器运算符**  
标准容器迭代器的运算符：  
- `*iter`，返回迭代器所指对象的引用（解引用）  
- `iter->mem`，解引用iter，并获取其成员mem，等价于`(*iter).mem`  
- `++iter`，令iter指示容器中的下一个元素  
- `--iter`，令iter指示容器中的上一个元素  
- `iter1?==?iter2`，如果两个迭代器指示的是同一个元素，或者它们都是尾后迭代器，则相等，反之不相等  
迭代器指示一个元素时，才可对其解引用。对尾后迭代器或者无效迭代器解引用的结果是UB。  
**迭代器类型**  
标准库类型使用iterator和const_iterator来表示迭代器类型。  
如：
```c++
vector<int>::iterator?it1;
vector<int>::const_iterator?it2;
```  
it1能读写元素，而it2只能读。  
认定某个类型是迭代器类型当且仅当它支持一套操作，这套操作使得我们能访问容器的元素，或者从某个元素移动到另外一个元素。  
**begin和end运算符**begin和end返回的具体类型由对象是否是常量决定。如果对象是常量，返回const_iterator，否则返回iterator。  
为了专门得到const_iterator类型的迭代器，C++11中可以使用cbegin和cend：  
```c++
auto?it?=?v.cbegin();
```  
**箭头运算符**即`->`，它把解引用和成员访问两个操作结合在一起。即：`(*iter).mem`等价于`iter->mem`。  
**某些对vector对象的操作会使迭代器失效**任何一种可能改变vector对象容量的操作，比如push_back，都会使该vector对象的迭代器失效。
### 迭代器运算  
递增运算令迭代器每次移动一个元素，所有的标准库容器的迭代器都支持递增运算，也支持==和!=运算。  
string和vector的迭代器提供了额外的运算符，有：  
- `iter?+?n`，新迭代器向前移动若干个元素，它指向容器的一个元素，或是尾后迭代器  
- `iter?- n`，新迭代器向后移动若干个元素，它指向容器的一个元素，或是尾后迭代器  
- `iter1?- iter2`，得到迭代器之间的距离，参与计算的迭代器必须是指向同一个容器中的元素或者尾元素的下一个位置  
- `>,>=,<,<=`，比较迭代器所处的位置，前面的小于后面的，参与计算的迭代器必须是指向同一个容器中的元素或者尾元素的下一个位置  ??
**迭代器的算数运算**  
迭代器相减的结果的类型是difference_type，表示右侧的迭代器要移动多少个位置才能到达左侧的。  
difference_type是一个带符号的整数，string和vector都定义了这个类型。  
**迭代器相加没有意义**
```c++
auto mid = (beg) +(end-beg)/2;//正确
auto mid =(beg+end)/2;//错误 迭代器加法不存在
```  
string类本身接受无参数的初始化方式，无论数组定义在函数体内部还是外部都被默认初始化为空串，对于内置类型int，数组定义在函数体外部时默认初始化为0，在main函数内部时，将不被初始化。

## 数组
1. 数组是存放相同类型的对象的容器，这些对象是匿名的。  
2. 数组的大小确定不变。  
3. 数组是一种内置类型。  
### 定义和初始化内置数组
数组是一种复合类型，其声明形如`a[N]`  。N叫维度，说明了数组中元素的个数，必须大于0，且必须是一个**常量表达式**，即其值在编译期间已知。  
默认情况下，数组的元素执行默认初始化，这意味着在函数块内定义的执行默认初始化的含内置类型元素的数组，其元素的值未定义。  
定义数组的时候必须指定数组的类型，不允许用auto关键字由初始值的列表推断类型。数组的元素应为对象，所以不存在存储引用的数组。  
**显式初始化数组元素**
即列表初始化，此时可以忽略数组的维度，维度由编译器推断出来。如：  
```c++
int?a1[10]?=?{0};?//?剩下的元素执行值初始化，即为0
int?a2[]?=?{1,?2,?3};
```
**字符数组的特殊性**可以用字符串字面值对此类数组进行初始化。如：  
```c++
char?s[]?=?"hello";
```
这样初始化的数组包含结尾的空字符。  
**不允许拷贝和赋值**
这样的操作是非法的：  
```c++
int?a1[]?=?{1,?2,?3};
int?a2[]?=?a1;?//?非法
```
**理解复杂的数组声明**  
1. 定义一个指针数组
```c++
int*?a[10]?=?{};
```  
2. 定义一个指向数组的指针：  
```c++
int?(*ptr)[10]?=?&a;
```  
3. 定义一个绑定到数组的引用：  
```c++
int?(&a_ref)[10]?=?a;
```  
默认情况下，类型修饰符从右向左依次绑定。不过理解数组的复杂声明时，应该由内向外理解。即从数组的名字开始按照由内向外的顺序阅读。  
### 访问数组元素  
使用数组下标的时候，通常将其定义为size_t类型，这是一种机器相关的无符号类型。定义在cstddef头文件中，是C标准库stddef.h头文件的C++版本。可以使用范围for语句来遍历数组。  
```c++
for?(auto?i?:?arr)
????cout?<<?i?<<?"?";
cout?<<?endl;
```  
**得到数组的大小**
```
sizeof(array/sizeof(array[0];
```
**检查下标的值**  
与string和vector一样，数组的下标是否在合理范围之内由程序员负责检查。  
### 指针和数组
在很多用到数组名字的地方，编译器都会自动地将其替换为一个**指向数组首元素的指针**。  
**decltype**
下面得到一个数组类型：   
```c++
int?a1[10]?=?{};
decltype(a1)?a2;
```  
**auto**
下面得到一个整型指针：
```c++
int?a1[10]?=?{};
auto?a2(a1);
```  
**指针也是迭代器**  
string和vector的迭代器支持的运算，指针都支持。使用递增运算符既可以让指向数组元素的指针向前移动到下一个位置上。这样可以获取数组尾元素的下一个位置的指针：
```c++
int?*end?=?&a[N];
```  
不过C++11提供了begin和end函数，可以获取数组首元素的指针和尾后指针：
```c++
int?a[10]?=?{};
int?*beg_p?=?begin(a);
int?*end_p?=?end(a);
```  
这俩函数定义在头文件iterator.h中。尾后指针不能解引用和递增操作。和迭代器一样，两个指针相减的结果是它们之间的距离。参与运算的两个指针必须指向同一个数组当中的元素。  
**下标和指针**  
对数组执行下标运算其实是对指向数组元素的指针执行下标运算：  
```c++
int?i?=?ia[2];????//?ia转换成指向数组首元素的指针
??????????????????//?ia[2]得到(ia?+?2)所指的元素
int?*p?=?ia;??????//?p指向ia的首元素
i?=?*(p?+?2);?????//?等价于i?=?ia[2]
```  
只要指针指向的是数组中的元素，都可以执行下标运算。  
内置的下标运算符可以处理负值，这和标准库类型的下标不一样（必须是无符号的）。  
### C风格字符串  
C风格的字符串即是字符串字面量，也是一种字符数组，并以空字符结尾（null?terminated）。
p109列举了C语言标准库提供的一组函数，可以操作C风格字符串，他们定义在cstring头文件中。  
**c_str函数**
string可使用c_str函数返回其C风格的字符串，如：  
```c++
string?s("hello");
const?char?*c_s?=?s.c_str();
```
无法保证返回的C风格字符串一直有效，因此通常在返回后再把它拷贝到另一个地方
**使用数组初始化vector对象**如：  
```c++
int?a[]?=?{1,?2,?3};
vector<int>?vec(begin(a),?end(a));
```  
## 多维数组
多维数组，实际上是数组的数组。
如：`int?a[3][4]`，可由内而外理解，a是一个含有3个元素的数组，每个元素又是一个含有4个元素的数组。
对于二维数组，常把第一个维度看作行，第二个维度看作列。  
**多维数组的初始化**如：  
```c++
int?a[3][4]?=?{
????{0,?1,?2,?3},
????{4,?5,?6,?7},
????{8,?9,?10,?11}
};
```  
列表初始化中未列出的元素执行值初始化。  
**多维数组的下标引用**  
如果表达式含有的下标运算符数量和维度一样多，该表达式的结果将是给定类型的元素；否则表达式的结果是内层数组
```c++
int?a[3][4]?=?{};
int?(&row)[4]?=?a[2];?//?row绑定到a的第二个数组上
```  
**使用范围for语句处理多维数组**  
如果是外层循环，控制变量将得到数组类型。
除了最内层的循环外，其他所有循环控制变量都应该是引用类型（因为若不是引用，编译器会认为外层控制变量是指针类型，而无法遍历一个指针）。  
**指针和多维数组**
当程序使用多维数组名字时，也会自动将其转换成指向数组首元素的指针。  
多维数组的首元素是一个内层数组，故使用多维数组名将得到一个指向内层数组的指针。  
即：
```c++
int?a[2][3]?=?{};
int?(*p)[3]?=?a;
```  
还可以使用auto或者begin来得到指向内层数组的指针。  
**类型别名简化多维数组的指针**  
可以这样定义一个数组类型：
```c++
using?int_arr?=?int[4];?//?C++11
typedef?int?int_arr[4];
```


























